#include <stdio.h>#include <stdlib.h>#include <p32xxxx.h>#include <plib.h>#include "dsplib_dsp.h"#include "fftc.h"/* SYSCLK = 8MHz Crystal/ FPLLIDIV * FPLLMUL/ FPLLODIV = 80MHzPBCLK = SYSCLK /FPBDIV = 80MHz*/#pragma config FPLLMUL = MUL_20, FPLLIDIV = DIV_2, FPLLODIV = DIV_1, FWDTEN = OFF#pragma config POSCMOD = HS, FNOSC = PRIPLL, FPBDIV = DIV_1/* Input array with 16-bit complex fixed-point twiddle factors. this is for 16-point FFT. For other configurations, for example 32 point FFT, Change it to fft16c32*/#define fftc fft16c1024/* defines the sample frequency*/#define SAMPLE_FREQ 3252/* number of FFT points (must be power of 2) */#define N 1024#define DEBOUNCE_TIME 20000// 7 Segment Display pmod using the TOP JA & JB jumpers// Segments#define SegA1 LATEbits.LATE0#define SegB1 LATEbits.LATE1#define SegC1 LATEbits.LATE2#define SegD1 LATEbits.LATE3#define SegE1 LATGbits.LATG9#define SegF1 LATGbits.LATG8#define SegG1 LATGbits.LATG7// Display selection. 0 = right, 1 = left (Cathode)#define DispSel1 LATGbits.LATG6// 7 Segment Display pmod using the TOP JC & JD jumpers// Segments#define SegA2 LATGbits.LATG12#define SegB2 LATGbits.LATG13#define SegC2 LATGbits.LATG14#define SegD2 LATGbits.LATG15#define SegE2 LATDbits.LATD7#define SegF2 LATDbits.LATD1#define SegG2 LATDbits.LATD9// Display selection. 0 = right, 1 = left (Cathode)#define DispSel2 LATCbits.LATC1#define C4   PORTBbits.RB0#define C3   PORTBbits.RB1#define C2   PORTBbits.RB2#define C1   PORTBbits.RB3#define R4   PORTBbits.RB4#define R3   PORTBbits.RB5#define R2   PORTBbits.RB8#define R1   PORTBbits.RB9// Define Pmod LDs as PLed1~PLed8 (JE jumper)#define PLed1   LATDbits.LATD14#define PLed2   LATDbits.LATD15#define PLed3   LATFbits.LATF2#define PLed4   LATFbits.LATF8#define PLed5   LATDbits.LATD13#define PLed6   LATDbits.LATD3#define PLed7   LATDbits.LATD11#define PLed8   LATCbits.LATC3int keypress = 0;int threshold = 14000;/* log2(1024)=10 */int log2N = 10;/* Input array with 16-bit complex fixed-point elements. *//* int 16c is data struct defined as following:  typedef struct{	int16 re;	int16 im;} int16c; */int16c sampleBuffer[N];//int16c ADC[N];/* intermediate array */int16c scratch[N];/* intermediate array holds computed FFT until transmission*/int16c dout[N];/* intermediate array holds computed single side FFT */int singleSidedFFT[N];/* array that stores the corresponding frequency of each point in frequency domain*/short freqVector[N];/* indicates the dominant frequency */int freq=0;// Function definitionsint computeFFT(int16c *sampleBuffer);//int computeFFT(int16c *ADC);/* * */unsigned char SSD_number[]={0b0111111,	//00b0000110,	//10b1011011,	//20b1001111,	//30b1100110,	//40b1101101,	//50b1111101,	//60b0000111,	//70b1111111,	//80b1101111,	//90b0111001,       //C0b0000000,	//clear0b1110110,       //H0b0111000,       //L0b1111001,       //E};void displayDigit (unsigned char value, int ssd, int dispsel){if (ssd == 1){SegA1 = value & 1;SegB1 = (value >> 1) & 1;SegC1 = (value >> 2) & 1;SegD1 = (value >> 3) & 1;SegE1 = (value >> 4) & 1;SegF1 = (value >> 5) & 1;SegG1 = (value >> 6) & 1;DispSel1 = dispsel;}//DispSel1 = 0;if (ssd == 2){SegA2 = value & 1;SegB2 = (value >> 1) & 1;SegC2 = (value >> 2) & 1;SegD2 = (value >> 3) & 1;SegE2 = (value >> 4) & 1;SegF2 = (value >> 5) & 1;SegG2 = (value >> 6) & 1;DispSel2 = dispsel;}}void showNumber(int digit, int ssd, int dispsel){    displayDigit(SSD_number[digit], ssd, dispsel);}void setPmodLed(int value){	// This function will be refered later   PLed1=(value & 0b10000000) >>7;   PLed2=(value & 0b01000000) >>6;   PLed3=(value & 0b00100000) >>5;   PLed4=(value & 0b00010000) >>4;   PLed5=(value & 0b00001000) >>3;   PLed6=(value & 0b00000100) >>2;   PLed7=(value & 0b00000010) >>1;   PLed8=(value & 0b00000001);}void initADC ( int amask){AD1PCFG = 0xF7fF; // all PORTB = digital but RB11 = analog (PIN 11 (PIN 2/JK on MIC)AD1CON1 = 0x00E0; // automatic conversion after samplingAD1CHS = 0x000b0000; // Connect RB11/AN11 as CH0 inputAD1CSSL = 0; // no scanning requiredAD1CON2 = 0; // use MUXA, AVss/AVdd used as Vref+/-AD1CON3 = 0x1FFF; // Tad = 512 x Tpb, Sample time = 31 TadAD1CON1bits.ADON = 1; // turn on the ADC}int readADC( int ch){AD1CON1bits.SAMP = 1; // 1. start samplingwhile (!AD1CON1bits.DONE); // 3. wait conversion completereturn ADC1BUF0; // 3. read conversion result}int ADC;int onesADC;int tensADC;int hunsADC;int i;int main() {     for (i=0; i<N/2; i++)	{            freqVector[i] = i*(SAMPLE_FREQ/2)/((N/2) - 1);	}    initADC(1);    //AD1PCFG=0xfbff; // all PORTB as digital except B11 (PIN 11 (PIN 2/JK on MIC))        TRISC = 0;	TRISD = 0;	TRISE = 0;	TRISF = 0;	TRISG = 0;        TRISB = 0x080f;        PORTC = 0x00;	PORTD = 0x00;	PORTE = 0x00;	PORTF = 0x00;	PORTG = 0x00;        PORTB = 0x00;   /*The following code example will enable Timer2 interrupts, load the Timer2 Periodregister and start the Timer.When a Timer2 period match interrupt occurs, the interrupt service routine must clearthe Timer2 interrupt status flag in software.*/T2CON = 0x0070; // Stop Timer and clear control register,TMR2 = 0x0; // Clear timer registerPR2 = 0x0099; // Load period register, prescaler = 256, PRx=152, 2048HzIPC2SET = 0x0000000D; // Set priority level=3IFS0CLR = 0x00000100; // Clear Timer interrupt status flagIEC0SET = 0x00000100; // Enable Timer interruptsT2CONSET = 0x8000; // Start Timer    // 1. Configure CNCON , CNEN, CNPUE    CNCON = 0x08000;    CNEN = 0x0000003C;    CNPUE = 0x0000003C;// 2. Perform a dummy read to clear mismatch    PORTB;// 3. Configure IPC6, IFS1, IEC1    IPC6SET = 0x00170000;    IFS1CLR = 0x0001;    IEC1SET = 0x0001;// 4. Enable vector interrupt INTEnableSystemMultiVectoredInt();R4 = R1 = R2 = R3 = 0;int i;int done=0;while(1){}//    return (EXIT_SUCCESS);}int computeFFT(int16c *sampleBuffer){	int i;        int dominant_freq=1;	/* computer N point FFT, taking sampleBuffer[] as time domain inputs         * and storing generated frequency domain outputs in dout[] */	mips_fft16(dout, sampleBuffer, fftc, scratch, log2N);	/* compute single sided fft */	for(i = 0; i < N/2; i++)	{		singleSidedFFT[i] = 2 * ((dout[i].re*dout[i].re) + (dout[i].im*dout[i].im));	}        /* find the index of dominant frequency, which is the index of the largest data points */        for(i = 1; i < N/2; i++)	{            if (singleSidedFFT[dominant_freq]<singleSidedFFT[i])                    dominant_freq=i;        }        return dominant_freq;}/*The following code example demonstrates a simple interrupt service routine for Timerinterrupts. The user?s code at this ISR handler should perform any applicationspecific operations and must clear the corresponding Timer interrupt status flagbefore exiting.*/void __ISR(_TIMER_2_VECTOR, ipl3) Timer2Handler(void){    int i;    int quit=0;    for (i=0; i<N; i++)        {            ADC = readADC(1);            sampleBuffer[i].re=ADC;            sampleBuffer[i].im=0;        }        /* compute the corresponding frequency of each data point in frequency domain*//*        for (i=0; i<N/2; i++)	{            freqVector[i] = i*(SAMPLE_FREQ/2)/((N/2) - 1);	} */        freq=freqVector[computeFFT(sampleBuffer)];    int onesfreq=0;    int tensfreq=0;    int hunsfreq=0;    int thousfreq=0;        thousfreq = freq/1000;        hunsfreq = (freq-thousfreq*1000)/100;        tensfreq = (freq-hunsfreq*100)/10;        onesfreq = freq%10;        hunsADC = (ADC)/100;        tensADC = (ADC-hunsADC*100)/10;        onesADC = ADC%10;       showNumber(hunsfreq, 2, 0);       //for (i=0;i<threshold;i++);       showNumber(tensfreq, 1, 1);       for (i=0;i<threshold;i++);      //  for (i=0;i<threshold;i++);        showNumber(onesfreq, 1, 0);        for (i=0;i<threshold;i++);         IFS0CLR = 0x00000100; // Be sure to clear the Timer 2 interrupt status}